# 项目概述

设计并实现了一款基于Qt框架的绘图应用程序，旨在提供直观的图形用户界面，让用户可以绘制和编辑各种基本图形，如直线、多边形、圆形、椭圆和曲线，并进行平移、旋转、缩放和裁剪操作。通过该应用程序，用户可以提高绘图效率和图形处理的精确性。

# 主要任务、难点与解决方案

## 1. 图元绘制与管理

1. **任务描述**：实现用户能够绘制并管理各种基本图元（直线、多边形、圆形、椭圆和曲线）。

2. **难点**：需要确保图元绘制的准确性和可编辑性，并提供直观的用户界面以支持各种绘图操作。

3. **解决方案**：使用Qt框架的绘图功能，通过QPainter类进行图元的绘制与管理。

4. **算法实现**：使用C++编写程序，通过继承QMainWindow类实现主窗口，使用QVector类管理图元的各个点，通过鼠标事件实现用户交互。

5. **具体步骤**：

   - 创建用户界面，包含各种绘图工具和操作选项。
   - 处理鼠标事件，实现图元的绘制、编辑和管理。
   - 使用QPainter类进行图元的绘制。
   - 定义Primitive类，封装各种图元及其操作方法。

6. **效果**：成功实现了各种图元的绘制和管理，用户可以通过简单的操作绘制和编辑各种基本图形，提高了绘图效率。

7. **示例**：

   - 用户界面：使用Qt Designer创建主窗口，包含绘图区域和工具栏。

   - 绘制图元：

     ```cpp
     // 重写绘制事件，当窗口需要重绘时调用
     void MainWindow::paintEvent(QPaintEvent *event) {
         QPainter painter(this); // 创建QPainter对象，用于绘制图元
         // 绘制所有已绘制的图元
         foreach (Primitive *p, primitives) {
             painter.setPen(p->pen()); // 设置画笔
             painter.drawPoints(p->points()); // 绘制图元的点
         }
     }
     ```

## 2. 平移、旋转和缩放

1. **任务描述**：实现图元的平移、旋转和缩放功能。

2. **难点**：需要确保图元在操作过程中保持正确的形状和位置。

3. **解决方案**：在Primitive类中实现平移、旋转和缩放的方法，通过鼠标事件获取用户输入，并调用相应的方法进行图元变换。

4. **算法实现**：使用C++编写程序，通过矩阵变换实现图元的平移、旋转和缩放。

5. **具体步骤**：

   - 在Primitive类中实现translate、rotate和scale方法。
   - 在鼠标事件处理函数中调用相应的方法进行图元变换。
   - 更新图元参数并重新绘制。

6. **效果**：成功实现了图元的平移、旋转和缩放功能，用户可以通过简单的拖拽和旋转操作调整图元的位置和大小。

7. **示例**：

   - 平移图元：

     ```cpp
     // 平移图元，返回平移后的图元参数
     QVector<QPoint> Primitive::translate(QPoint pos) {
         QVector<QPoint> args = _args;
         // 根据图元类型进行不同的平移操作
         if (_type == Circle || _type == Ellipse) {
             args[0] += pos; // 圆形和椭圆只需平移中心点
         } else {
             for (int i = 0; i < args.size(); ++i) {
                 args[i] += pos; // 其他图元平移所有点
             }
         }
         return args;
     }
     ```

   - 旋转图元：

     ```cpp
     // 旋转图元，返回旋转后的图元参数
     QVector<QPoint> Primitive::rotate(qreal r) {
         QVector<QPoint> args = _args;
         qreal cosr = qCos(r), sinr = qSin(r); // 计算旋转角度的余弦和正弦
         int dx, dy;
         if (_type != Circle && _type != Ellipse) {
             for (auto& arg : args) {
                 dx = arg.x() - _center.x();
                 dy = arg.y() - _center.y();
                 arg.rx() = int(_center.x() + dx * cosr - dy * sinr); // 旋转后的x坐标
                 arg.ry() = int(_center.y() + dx * sinr + dy * cosr); // 旋转后的y坐标
             }
         }
         return args;
     }
     ```

   - 缩放图元：

     ```cpp
     // 缩放图元，返回缩放后的图元参数
     QVector<QPoint> Primitive::scale(qreal s) {
         QVector<QPoint> args = _args;
         if (_type == Circle || _type == Ellipse) {
             args[1] *= s; // 圆形和椭圆只需缩放半径
         } else {
             for (auto& arg : args) {
                 arg = _center + (arg - _center) * s; // 其他图元相对于中心点进行缩放
             }
         }
         return args;
     }
     ```

## 3. 图元裁剪

1. **任务描述**：实现图元的裁剪功能。

2. **难点**：需要确保裁剪后的图元形状和位置正确，并与裁剪区域匹配。

3. **解决方案**：在Primitive类中实现clip方法，通过鼠标事件获取用户输入的裁剪区域，并调用clip方法进行图元裁剪。

4. **算法实现**：使用C++编写程序，通过计算裁剪区域与图元的交集，实现图元的裁剪。

5. **具体步骤**：

   - 在Primitive类中实现clip方法，计算裁剪后的图元参数。
   - 在鼠标事件处理函数中获取裁剪区域，并调用clip方法进行裁剪。
   - 更新图元参数并重新绘制。

6. **效果**：成功实现了图元的裁剪功能，用户可以通过简单的操作裁剪图元，调整图元的显示区域。

7. **示例**：

   - 裁剪图元：

     ```cpp
     // 裁剪图元，返回裁剪后的图元参数
     QVector<QPoint> Primitive::clip(QPoint lt, QPoint rb) {
         int l = qMin(lt.x(), rb.x()), r = qMax(lt.x(), rb.x());
         int t = qMin(lt.y(), rb.y()), b = qMax(lt.y(), rb.y());
         QVector<QPoint> args = _args;
     
         // 使用Cohen-Sutherland算法裁剪线段
         auto lambda = [=](int x, int y) {
             uint8_t code = 0;
             if (y < t) code |= 8;
             if (y > b) code |= 4;
             if (x > r) code |= 2;
             if (x < l) code |= 1;
             return code;
         };
     
         if (_type == Line) {
             int x1 = args[0].x(), y1 = args[0].y();
             int x2 = args[1].x(), y2 = args[1].y();
             uint8_t code1 = lambda(x1, y1), code2 = lambda(x2, y2), code;
     
             while (code1 || code2) {
                 if (code1 & code2) break; // 完全在外部区域
                 code = code1 ? code1 : code2;
     
                 int x = 0, y = 0;
                 if (1 & code) { x = l; y = y1 + (y2 - y1) * (l - x1) / (x2 - x1); }
                 else if (2 & code) { x = r; y = y1 + (y2 - y1) * (r - x1) / (x2 - x1); }
                 else if (4 & code) { y = b; x = x1 + (x2 - x1) * (b - y1) / (y2 - y1); }
                 else if (8 & code) { y = t; x = x1 + (x2 - x1) * (t - y1) / (y2 - y1); }
     
                 if (code == code1) { x1 = x; y1 = y; code1 = lambda(x1, y1); }
                 else { x2 = x; y2 = y; code2 = lambda(x2, y2); }
             }
             args = {{x1, y1}, {x2, y2}};
         }
         return args;
     }
     ```

## 4. 动态调整图元

1. **任务描述**：实现用户在调整图元参数后，图元自动更新。

2. **难点**：需要实时监控用户输入，并动态更新已有图元。

3. **解决方案**：实现参数输入框的事件监听功能，当参数变化时，调用更新函数重新生成图元。

4. **算法实现**：使用C++编写程序，监听参数输入框的变化事件，动态更新图元。

5. **具体步骤**：

   - 监听用户输入框的变化事件，使用Qt的信号槽机制。
   - 获取最新的参数值。
   - 调用相应的图元更新方法，重新绘制图元。

6. **效果**：实现了图元的动态调整，用户修改参数后，图元能实时更新，确保绘图的一致性和准确性。

7. **示例**：

   - 监听事件：

     ```cpp
     // 在主窗口构造函数中连接信号槽
     connect(ui->paramEdit, SIGNAL(textChanged(QString)), this, SLOT(updatePrimitive()));
     ```

   - 更新图元：

     ```cpp
     void MainWindow::updatePrimitive() {
         // 获取最新的参数值
         QString text = ui->paramEdit->text();
         qreal value = text.toDouble();
     
         // 更新当前图元的参数
         if (primitive) {
             QVector<QPoint> args = primitive->args();
             // 根据图元类型和参数更新图元
             switch (primitive->type()) {
                 case Primitive::Line:
                     args[1].setX(args[0].x() + value); // 更新线的终点
                     break;
                 case Primitive::Circle:
                     args[1].setX(value); // 更新圆的半径
                     break;
                 // 其他类型图元的更新
                 ...
             }
             primitive->setArgs(args); // 设置新的参数
             update(); // 重新绘制图元
         }
     }
     ```

# 项目成果

1. **实现了Qt框架中的图元绘制功能**
   - 成功实现了根据用户操作绘制各种基本图元（直线、多边形、圆形、椭圆和曲线）的功能。用户可以通过简单的操作绘制精确的图元，提高了绘图效率。
   - 新增了平移、旋转和缩放功能，用户可以方便地调整图元的位置和大小，确保图纸上的图元始终准确，满足工程设计的精度要求。
2. **提供了图元裁剪功能**
   - 实现了图元的裁剪功能，用户可以根据需要裁剪图元的显示区域，调整图元的形状和位置。
   - 裁剪后的图元与裁剪区域匹配，确保了绘图的一致性和准确性。
3. **实现了动态调整图元功能**
   - 用户可以通过参数输入实时调整图元的形状和位置，实现了图元的动态更新。
   - 这一功能确保了图元与用户输入参数的一致性，提高了绘图的灵活性和效率。





